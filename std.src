pass
mov 0 r1
bind continue ip
	mov r2 r0
	movw r3 !/
	cmp [r0] r3
	jne !append
	add r0 r0 !8
	cmp [r0] r3
	jne !append
	bind inner ip
		add r0 r0 !8
		movw r3 !
		cmp [r0] r3
		jne !inner 
		add r0 r0 !8
		jmp !continue 
	bind append ip
	mov r0 r2
	mov [r1] [r0]
	add r1 r1 !8
	add r0 r0 !8
	cmp r0 0
	jlt !continue
bind break ip
mov r0 !1
int	
end

// the above pass defines line comments

// byte literal blocks for passes
pass
movw 0 !pass_literal_bytes
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	bind change ip
		cmp [r0] 0
		jeq !break
		movw [r1] !movw add r1 r1 !8
		movw [r1] !\[   add r1 r1 !8
		movw [r1] !r1   add r1 r1 !8
		movw [r1] !\]   add r1 r1 !8
		movw [r1] !\!   add r1 r1 !8
		mov  [r1] [r0]  add r1 r1 !8
		movw [r1] !add  add r1 r1 !8
		movw [r1] !r1   add r1 r1 !8
		movw [r1] !r1   add r1 r1 !8
		movw [r1] !\!   add r1 r1 !8
		mov  [r1] !8    add r1 r1 !8
		add r0 r0 !8
		jmp !change
	bind break ip
	add r0 r0 !8
	cmp r0 8
	jeq !exit
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// stack initialization
pass
movw 0 !stack_init
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	pass_literal_bytes
comp
	mov r1 !mtp
	sub 0 r1 !8
	sub 8 0 !8
	sub 10 8 !8
	bind fsp !200
	mov fsp !208
	mov [fsp] !0
	mov r0 !1
	int
run
bind sp 0
bind fp 8
bind tmp 10
mov sp !sp
mov fp sp
	pass_literal_bytes
	add r0 r0 !8
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

// multicore register setup
pass
movw 0 !core_register_init
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	pass_literal_bytes
comp
	mul r1 !6 !8
	mul r2 r1 !2
	mul r3 r1 !3
	add 0  !r0 r1
	add 8  !r1 r1
	add 10 !r2 r1
	add 18 !r3 r1
	add 20 !r0 r2
	add 28 !r1 r2
	add 30 !r2 r2
	add 38 !r3 r2
	add 40 !r0 r3
	add 48 !r1 r3
	add 50 !r2 r3
	add 58 !r3 r3
	mov r0 !1
	int
run
bind r01 0
bind r11 8
bind r21 10
bind r31 18
bind r02 20
bind r12 28
bind r22 30
bind r32 38
bind r03 40
bind r13 48
bind r23 50
bind r33 58
bind save_r0 !r0
bind save_r1 !r1
bind save_r2 !r2
bind save_r3 !r3
	pass_literal_bytes
	add r0 r0 !8
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

// whitespace skip for pass
pass
movw 0 !pass_whitespace
mov 8 r1
// newline
bind loop ip
	cmp [r0] 0
	jne !next
	pass_literal_bytes
bind pass_loop ip
movw r2 ! 
cmp [r0] r2
jeq !pass_skip
movw r2 !	
cmp [r0] r2
jeq !pass_skip
movw r2 !
cmp [r0] r2
jeq !pass_skip
jmp !pass_end
bind pass_skip ip
add r0 r0 !8
cmp r0 !8
jeq !pass_end
jmp !pass_loop
bind pass_end ip
unbind pass_loop
unbind pass_skip
unbind pass_end
	pass_literal_bytes
	add r0 r0 !8
	jmp !loop	
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

pass
movw 0 !pass_location
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_literal_bytes
movw r2 !\!
cmp [r0] r2
jeq !parse_imm
movw r2 !\[
cmp [r0] r2
jeq !parse_deref
jmp !parse_imm
bind parse_deref ip
	movw r2 !\]
	cmp [r0] r2
	jeq !parse_end
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	jmp parse_deref
unbind parse_deref
bind parse_imm ip
	movw r2 ! 
	cmp [r0] r2
	jeq !parse_end
	movw r2 !	
	cmp [r0] r2
	jeq !parse_end
	movw r2 !
	cmp [r0] r2
	jeq !parse_end
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	jmp parse_imm
unbind parse_imm
bind parse_end ip
unbind parse_end
	pass_literal_bytes
	cmp r0 8
	jne !loop
	jmp !exit
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// stack push operation
pass
movw 0 !psh
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_literal_bytes
comp
	add [fsp] [fsp] !8
	mov r0 !1
	int
run
sub sp sp !8
mov [sp]
	pass_literal_bytes
	bind next ip	
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

// stack pop operation
pass
movw 0 !pop
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_literal_bytes
comp
	sub [fsp] [fsp] !8
	mov r0 !1
	int
run
mov 
	pass_literal_bytes
	pass_whitespace
	pass_location
	pass_literal_bytes
[sp]
add sp sp !8
	pass_literal_bytes
	bind next ip	
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

// byte literal blocks for passes
pass
movw 0 !pass_literal_content
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	bind change ip
		cmp [r0] 0
		jeq !break
		movw [r1] !movw add r1 r1 !8
		movw [r1] !\[   add r1 r1 !8
		movw [r1] !r1   add r1 r1 !8
		movw [r1] !\]   add r1 r1 !8
		movw [r1] !\!   add r1 r1 !8
		mov  [r1] [r0]  add r1 r1 !8
		movw [r1] !add  add r1 r1 !8
		movw [r1] !r1   add r1 r1 !8
		movw [r1] !r1   add r1 r1 !8
		movw [r1] !\!   add r1 r1 !8
		mov  [r1] !8    add r1 r1 !8
		add r0 r0 !8
		jmp !change
	bind break ip
	add r0 r0 !8
	cmp r0 8
	jeq !exit
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// return retrieve from call
pass
movw 0 !<
movw 10 !-
movw 18 !(
movw 20 !)
mov 8 r1
bind loop ip
	mov 28 r0
	add r0 r0 !8
	pass_whitespace
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	cmp r0 8
	jge !exit
	cmp [r0] 10
	jne !next
	add r0 r0 !8
	cmp r0 8
	jge !exit
	pass_whitespace
	cmp [r0] 18
	jne !next	
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jge !exit
	bind until_close ip
		cmp [r0] 20
		jeq !break
		mov [r1] [r0]
		add r0 r0 !8
		add r1 r1 !8
		cmp r0 8
		jge !exit
		jmp !until_close
	bind break ip
	mov [r1] [r0]
	add r1 r1 !8
	pass_literal_bytes
mov
	pass_literal_bytes
	mov [r1] [28] //NOTE only one token, doesnt do dereferences for now
	add r0 r0 !8
	add r1 r1 !8
	pass_literal_bytes
[sp]
add sp sp !8
	pass_literal_bytes
	cmp r0 8
	jge !exit
	jmp !loop
	bind next ip
	mov [r1] [28]
	add r0 28 !8
	add r1 r1 !8
	cmp r0 8
	jlt !loop
bind exit ip
mov r0 !1
int
end

// stack procedure call with arguments
pass
movw 0 !(
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_whitespace
	mov 10 [r0]
	add r0 r0 !8
	movw r2 !)
	bind until_close ip
		cmp [r0] r2
		jeq !close
		mov [r1] [r0]
		add r0 r0 !8
		add r1 r1 !8
		cmp r0 8
		jeq !exit
		jmp !until_close
	bind close ip
	add r0 r0 !8
	movw [r1] !call
	add r1 r1 !8
	mov [r1] 10
	add r1 r1 !8
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// stack procedure call
pass
movw 0 !call
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_whitespace
	pass_literal_content
comp
	add [fsp] [fsp] !8
	mov r0 !1
	int
run
sub sp sp !8
movw [sp] !current
psh fp
mov fp sp
jmp
	pass_literal_content
	movw [r1] !\!
	add r1 r1 !8
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	pass_literal_content
pop tmp
bind current ip
unbind current
	pass_literal_content
	cmp r0 8
	jne !loop
	jmp !exit
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// stack procedure return
pass
movw 0 !ret
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_whitespace
	pass_literal_content
mov sp fp
mov fp [sp]
add sp sp !8
mov tmp [sp]
mov [sp]
	pass_literal_content
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	pass_literal_content
jmp tmp
	pass_literal_content
	cmp r0 8
	jne !loop
	jmp !exit
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// standard pass
pass
movw 0 !var
movw 10 !=
movw 18 !;
mov 8 r1
bind loop ip
	mov 28 r0
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	cmp r0 8
	jge !exit
	pass_whitespace
	mov 20 [r0]
	add r0 r0 !8
	cmp r0 8
	jge !exit
	pass_whitespace
	cmp [r0] 10
	jne !next
	add r0 r0 !8
	pass_whitespace
	bind inner ip
		cmp [r0] 18
		jeq !break
		mov [r1] [r0]
		add r0 r0 !8
		add r1 r1 !8
		cmp r0 8
		jge !exit
		jmp !inner
	bind break ip
	add r0 r0 !8
	pass_literal_bytes
bind
	pass_literal_bytes
	mov [r1] 20
	add r1 r1 !8
pass_literal_bytes
[fsp]
pass_literal_bytes
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jmp !loop
	bind next ip
	mov r0 28
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// primitive u64
pass
movw 0 !nat
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	pass_whitespace
	pass_literal_content
psh
	pass_literal_content
	movw [r1] !\!
	add r1 r1 !8
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jeq !exit
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// frame_stack_pop
pass
movw 0 !frame_stack_pop
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	pass_literal_bytes
comp
	sub fsp fsp !8
	mov r0 !1
	int
run
	pass_literal_bytes
	add r0 r0 !8
	jmp !loop 
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

// frame_stack_push
pass
movw 0 !frame_stack_push
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	pass_literal_bytes
comp
	add fsp fsp !8
	mov [fsp] !0
	mov r0 !1
	int
run
	pass_literal_bytes
	add r0 r0 !8
	jmp !loop 
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
mov r0 !1
int
end

// copy value semantics 
pass
movw 0 !$
mov 8 r1
bind loop ip
	cmp [r0] 0
	jne !next
	add r0 r0 !8
	cmp r0 8
	jge !next
	pass_literal_content
sub tmp fp
	pass_literal_content
	movw [r1] !\!
	add r1 r1 !8
	mov [r1] [r0]
	add r1 r1 !8
	add r0 r0 !8
	pass_literal_content
psh [tmp]
	pass_literal_content
	cmp r0 8
	jge !exit
	jmp !loop
	bind next ip
	mov [r1] [r0]
	add r0 r0 !8
	add r1 r1 !8
	cmp r0 8
	jne !loop
bind exit ip
mov r0 !1
int
end

// standard pass
// pass
// mov 8 r1
// bind loop ip
	// mov [r1] [r0]
	// add r0 r0 !8
	// add r1 r1 !8
	// cmp r0 8
	// jne !loop
// mov r0 !1
// int
// end

// test
stack_init
core_register_init
(main)
mov r0 !1
int 

bind sum ip
	frame_stack_push
	add r1 fp !10
	add r2 fp !18
	mov r1 [r1]
	mov r2 [r2]
	add r3 r1 r2
	ret r3
	frame_stack_pop

bind main ip
	frame_stack_push
	bind loop ip
		var x = nat 6;
		var y = (sum nat 7 nat 8);
		r0 <- (sum $x $y)
		jmp !loop
	frame_stack_pop

