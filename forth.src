bind 1 +comment:// ... $ {
	
}

bind 1 hoist_anchor {
	[ mov
	| movh
	| movl
	| add
	| sub
	| mul
	| div
	| mod
	| and
	| or
	| xor
	| not
	| com
	| int
	| jmp
	| cmp
	| jle
	| jge
	| jlt
	| jgt
	| jeq
	| jne
	| shl
	| shr
	| bind
	| explicit_hoist_anchor
	]
}

bind 1 label +name {
	bind 0 name = ip
}

bind 1 let +name +binding:\= ... in +body:\{ ... \} {
	comptime {
		body
	}
	bind 0 name = binding
}

bind 1 comptime +body:\{ ... \} {
	comp
		explicit_hoist_anchor
		body
		mov r0 !1
		int
	run
	explicit_hoist_anchor
}

comptime{
	let tmp = r1 in {
		mov r1 !mtp
		sub r1 r1 !8
	}
	let sp = r1 in { sub r1 r1 !8 }
	let fp = r1 in { sub r1 r1 !8 }
	mov sp !mtp
	sub sp sp !10
	mov fp sp
}

bind 0 tmp = !tmp

bind 0 sp = !sp
bind 0 fp = !fp
mov sp !mtp
sub sp sp !10
mov fp sp

bind 1 +x integer {
	sub sp sp !8
	mov [sp] !x
}

bind 1 , +x {
	sub sp sp !8
	mov [sp] x
}

bind 1 pop +r {
	mov r [sp]
	add sp sp !8
}

bind 1 stderr {
	mov r0 !2
	pop r1
	int
	,r1
}

bind 1 $ \: +word +body:% ... \; {
	bind 1 word {
		body
	}
}

bind 1 +bytes:\" ,,, \" {
	bytes{c
		sub sp sp !8
	}
	mov r0 sp
	mov r1 !0
	bytes{c
		mov [r0] c
		add r0 r0 !8
		add r1 r1 !1
	}
	,r1
}

bind 1 \+ {
	pop r0
	pop r1
	add r0 r0 r1
	,r0
}

bind 1 \- {
	pop r0
	pop r1
	sub r0 r1 r0
	,r0
}

bind 1 * {
	pop r0
	pop r1
	mul r0 r0 r1
	,r0
}

bind 1 end {
	mov r0 !1
	int
}

bind 1 explicit_hoist_anchor {
}

bind 1 dup {
	pop r0
	,r0 ,r0
}

bind 1 ovr {
	pop r0
	pop r1
	,r1 ,r0 ,r1
}

bind 1 swp {
	pop r0
	pop r1
	,r0 ,r1
}

bind 1 top {
	[sp]
}

bind 1 pop_ {
	add sp sp !8
}

bind 1 zero {
	ovr
	pop r3
	cmp r3 !0
	pop r1
	jeq r1
}

bind 1 jump {
	pop r0
	jmp r0
}

// test

:square dup * ;

:cube dup dup * * ;

:print
	label loop
		,return zero
			swp stderr pop_
			1 integer -
		,loop jump
	label return;

:stack_buffer 0 integer dup dup dup dup dup dup dup;

:main "hello world" print end;

stack_buffer main



